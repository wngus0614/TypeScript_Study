// 타입추론
// 타입스크립트는 타입이 정의되어 있지 않은 변수의 타입을 자동으로 추론합니다. 이런 기능을 “타입 추론”이라고 합니다.
let a = 10;
// number 타입으로 추론
// 따라서 타입스크립트는 프로그래머에게 모든 변수에 일일이 타입을 정의하지 않아도 되는 편리함을 제공합니다. 그러나 모든 상황에 타입을 잘 추론하는 것은 아닙니다.


// 타입 추론이 가능한 상황들
// 1. 변수 선언
// 일반적인 변수 선언의 경우 초기값을 기준으로 타입이 잘 추론됩니다.
let b = 10;
// number 타입으로 추론

let c = "hello";
// string 타입으로 추론

let d = {
  id: 1,
  name: "이주현",
  profile: {
    nickname: "wngus",
  }
};
// id, name, profile 프로퍼티가 있는 객체 타입으로 추론

// 2. 구조 분해 할당
// 객체와 배열을 구조 분해 할당하는 상황에서도 타입이 잘 추론됩니다.
let { id, name, profile } = d;

let [one, two, three] = [1, "hello", true];

// 3. 함수의 반환값
// 함수 반환값의 타입은 return 문을 기준으로 잘 추론됩니다.
function func() {
  return "hello";
}
// 반환값이 string 타입으로 추론된다.

// 4. 기본값이 설정된 매개변수
// 기본값이 설정된 매개변수의 타입은 기본값을 기준으로 추론됩니다.
function func2(message = "hello") {
  return "hello";
}


// 주의해야 할 상황들
// 1. 암시적으로 any타입으로 추론
// 변수를 선언할때 초기값을 생략하면 암시적인 any 타입으로 추론됩니다. 
// 참고로 이때 매개변수의 타입이 암시적 any로 추론될 때와 달리 일반 변수의 타입이 암시적 any 타입으로 추론되는 상황은 오류로 판단하지 않습니다.
let e;
// 암시적인 any 타입으로 추론
// 그리고 이 변수에 값을 할당하면 그 다음 라인부터 any 타입이 해당 값의 타입으로 변화합니다.
let f;
f = 10;
f.toFixed();

f = "hello";
f.toUpperCase();
// f.toFixed(); // 오류 

// f = 10; 다음 라인부터는 f가 number 타입이 되고, f = “hello” 다음 라인부터는 f가 string 타입이 됩니다. 
// 따라서 마지막 라인에서 f가 string 타입일 때 toFixed 같은 number 타입의 메서드를 사용하려고 하면 오류가 발생합니다. 
// 이렇게 암시적으로 추론된 any 타입은 코드의 흐름에 따라 타입이 계속 변화합니다. 이를 any의 진화라고 표현하기도 합니다.

// 2. const 상수의 추론
// const로 선언된 상수도 타입 추론이 진행됩니다. 그러나 let으로 선언한 변수와는 다른 방식으로 추론됩니다.
const num = 10;
// 10 Number Literal 타입으로 추론

const str = "hello";
// "hello" String Literal 타입으로 추론
// 상수는 초기화 때 설정한 값을 변경할 수 없기 때문에 특별히 가장 좁은 타입으로 추론됩니다. 


// 최적 공통 타입(Best Common Type)
// 다음과 같이 다양한 타입의 요소를 담은 배열을 변수의 초기값으로 설정하면, 최적의 공통 타입으로 추론됩니다.
let arr = [1, "string"];
// (string | number)[] 타입으로 추론
